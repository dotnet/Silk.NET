using static PointerGenerator.Generator;

namespace PointerGenerator
{
    public static class Generator
    {
        const bool OUTERMOST_ON_RIGHT = false;

        public enum PointerType : byte
        {
            Ptr,
            Mut
        }

        public static void GenerateTypes(string outputDir, int depth)
        {
            GenerateTypes(outputDir, depth - 1, null, PointerType.Ptr);
            GenerateTypes(outputDir, depth - 1, null, PointerType.Mut);
        }

        private static void GenerateTypes(string outputDir, int depthRemaining, PointerType[]? typeChain, PointerType finalType)
        {
            PointerType[] chain = new PointerType[typeChain is null ? 1 : typeChain.Length + 1];
            if (typeChain is not null)
            {
                Array.Copy(typeChain, chain, typeChain.Length);
            }
            chain[chain.Length - 1] = finalType;

            GenerateType(outputDir, chain);

            if (depthRemaining > 0)
            {
                GenerateTypes(outputDir, depthRemaining - 1, chain, PointerType.Ptr);
                GenerateTypes(outputDir, depthRemaining - 1, chain, PointerType.Mut);
            }
        }

        public static void GenerateType(string outputDir, params PointerType[] typeChain)
        {
            if (typeChain.Length == 0)
                return;

            string text, name;

            text = GeneratePointerType(out name, false, typeChain);
            File.WriteAllText(Path.Combine(outputDir, name + ".gen.cs"), text);
            text = GeneratePointerType(out name, true, typeChain);
            File.WriteAllText(Path.Combine(outputDir, name + ".generic.gen.cs"), text);
        }

        private static string GenerateSingleDimensionPointerType(out string name, bool generic, PointerType pointerType)
        {
            name = pointerType.ToString();
            string fullName = name;
            string fullCommentName = name;
            string arrayType = "byte";
            string rOField = pointerType == PointerType.Ptr ? "readonly " : string.Empty;
            string rOInRef = pointerType == PointerType.Ptr ? "in" : "ref";
            string getRef = pointerType == PointerType.Ptr ? "ref Unsafe.AsRef(in Ref)" : "ref Ref";
            string getObjectRef = pointerType == PointerType.Ptr ? "ref Unsafe.AsRef(in ptr.Ref)" : "ref ptr.Ref";
            string spanType = pointerType == PointerType.Ptr ? "ReadOnlySpan" : "Span";
            string WhereClause = string.Empty;
            if (generic)
            {
                fullName += "<T>";
                fullCommentName += "{T}";
                arrayType = "T";
                WhereClause = "\n\twhere T : unmanaged";
            }
            return
$$"""
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// ============================================= THIS FILE IS AUTOGENERATED ============================================
// =============================== Please make any edits in eng/pointergen/Generator.cs! ===============================
// ============================================= THIS FILE IS AUTOGENERATED ============================================

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Silk.NET.Core;

/// <summary>
/// A single dimension pointer wrapper
/// </summary>
public readonly ref struct {{fullName}}{{WhereClause}}
{
    /// <summary>
    /// Creates a pointer with the given underlying ref.
    /// </summary>
    /// <param name="Ref">The underlying ref.</param>
    public {{name}}(ref {{rOField}}{{arrayType}} @Ref)
    {
        this.Ref = ref @Ref;
    }

    /// <summary>
    /// The underlying reference.
    /// </summary>
    public readonly ref {{rOField}}{{arrayType}} Ref;

    /// <summary>
    /// Gets the item at the given offset from this pointer.
    /// </summary>
    /// <param name="index">The index.</param>
    public ref {{rOField}}{{arrayType}} this[nuint index]
    {
        [MethodImpl(
        MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization
    )]
        get => ref Unsafe.Add({{getRef}}, index);
    }

    /// <summary>
    /// Gets the underlying reference.
    /// </summary>
    /// <returns>The underlying reference.</returns>
    /// <remarks>
    /// This function allows a <see cref="{{fullCommentName}}"/> to be used in a <c>fixed</c> statement.
    /// </remarks>
    public ref {{rOField}}{{arrayType}} GetPinnableReference() => ref Ref;

    /// <summary>
    /// Creates a span with the given length from this pointer.
    /// </summary>
    /// <param name="length">the span length</param>
    /// <returns>the span</returns>
    public {{spanType}}<{{arrayType}}> AsSpan(int length) => MemoryMarshal.Create{{spanType}}({{getRef}}, length);

    /// <summary>
    /// Determines if this <see cref="{{fullCommentName}}"/> equals another object
    /// Always returns false as ref structs cannot be passed in, meaning this will never be true
    /// </summary>
    /// <param name="obj"></param>
    /// <returns>Whether this object is the same as </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public override bool Equals([NotNullWhen(true)] object? obj) => false;

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public override int GetHashCode() => Ref.GetHashCode();

    /// <summary>
    /// Determines if two <see cref="{{fullCommentName}}"/> objects are equivalent
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the pointers are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static bool operator ==({{fullName}} lh, {{fullName}} rh) => (void*)lh == (void*)rh;

    /// <summary>
    /// Determines if two <see cref="{{fullCommentName}}"/> objects are not equivalent
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the pointers are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static bool operator !=({{fullName}} lh, {{fullName}} rh) => (void*)lh != (void*)rh;

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a Nullptr
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator {{fullName}}(NullPtr ptr) => (void*)ptr;

    /// <summary>
    /// Determines whether a <see cref="{{fullCommentName}}"/> and a NullPtr are equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the <see cref="{{fullCommentName}}"/> and NullPtr are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==({{fullName}} lh, NullPtr rh) => lh == ({{fullName}})rh;

    /// <summary>
    /// Determines whether a <see cref="{{fullCommentName}}"/> and a NullPtr are not equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the <see cref="{{fullCommentName}}"/> and NullPtr are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=({{fullName}} lh, NullPtr rh) => lh != ({{fullName}})rh;

    /// <summary>
    /// Determines whether a NullPtr and a <see cref="{{fullCommentName}}"/> are equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the NullPtr and <see cref="{{fullCommentName}}"/> are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==(NullPtr lh, {{fullName}} rh) => ({{fullName}})lh == rh;

    /// <summary>
    /// Determines whether a NullPtr and a <see cref="{{fullCommentName}}"/> are not equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the NullPtr and <see cref="{{fullCommentName}}"/> are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=(NullPtr lh, {{fullName}} rh) => ({{fullName}})lh != rh;

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a span
    /// </summary>
    /// <param name="span"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(Span<{{arrayType}}> span) => new(ref span.GetPinnableReference());

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a byte pointer
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator {{fullName}}({{arrayType}}* ptr) => new(ref Unsafe.AsRef<{{arrayType}}>(ptr));

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a void pointer
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator {{fullName}}(void* ptr) => new(ref Unsafe.AsRef<{{arrayType}}>(ptr));

    /// <summary>
    /// Creates a byte pointer from a <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static explicit operator {{arrayType}}*({{fullName}} ptr) => ({{arrayType}}*)Unsafe.AsPointer({{getObjectRef}});

    /// <summary>
    /// Creates a void pointer from a <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static explicit operator void*({{fullName}} ptr) => Unsafe.AsPointer({{getObjectRef}});

    /// <summary>
    /// creates a <see cref="{{fullCommentName}}"/> from an array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}({{arrayType}}[] array) => array.AsSpan();

    /// <summary>
    /// creates a <see cref="{{fullCommentName}}"/> from a 2D array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}({{arrayType}}[,] array) => MemoryMarshal.CreateSpan(ref array[0, 0], array.Length);

    /// <summary>
    /// creates a <see cref="{{fullCommentName}}"/> from a 3D array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}({{arrayType}}[,,] array) => MemoryMarshal.CreateSpan(ref array[0, 0, 0], array.Length);
""" + (generic ? $$"""


    /// <summary>
    /// Creates a string from a <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static explicit operator string({{fullName}} ptr)
    {
        if (typeof(T) == typeof(char) || typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
        {
            fixed (void* raw = ptr)
            {
                return new string((char*)raw);
            }
        }

        if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
        {
            fixed (void* raw = ptr)
            {
                return Encoding.UTF8.GetString(
                    MemoryMarshal.CreateReadOnlySpanFromNullTerminated((byte*)raw)
                );
            }
        }

        if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
        {
            fixed (void* raw = ptr)
            {
                int words;
                for (words = 0; ((uint*)raw)[words] != 0; words++)
                {
                    // do nothing
                }

                return Encoding.UTF32.GetString((byte*)raw, words * 4);
            }
        }

        throw new InvalidCastException();
    }

    /// <summary>
    /// Create a non-generic version of <see cref="Mut{T}"/>
    /// </summary>
    /// <param name="ptr"></param>
    public static implicit operator {{name}}({{fullName}} ptr) => new {{fullName}}({{rOInRef}} ptr.Ref);
""" :
$$"""


    /// <summary>
    /// Creates a string from this <see cref="{{fullCommentName}}"/> with the given length
    /// </summary>
    /// <param name="length">length of the string</param>
    /// <returns>the string</returns>
    public unsafe string ReadToString(int length) => Encoding.UTF8.GetString(AsSpan(length));

    /// <summary>
    /// Creates a string from this <see cref="{{fullCommentName}}"/> as a c-style string
    /// </summary>
    /// <returns>the string</returns>
    public unsafe string ReadToString()
    {
        return Encoding.UTF8.GetString(
            MemoryMarshal.CreateReadOnlySpanFromNullTerminated(
                (byte*)Unsafe.AsPointer({{getRef}})));
    }

    /// <summary>
    /// Creates a string from a <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static explicit operator string({{fullName}} ptr) => ptr.ReadToString();
""")
    + (pointerType == PointerType.Mut ? "\n}" : (generic ?
$$"""


    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a ReadOnlySpan
    /// </summary>
    /// <param name="span"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(ReadOnlySpan<{{arrayType}}> span) => new(in span.GetPinnableReference());

    /// <summary>
    /// creates a <see cref="{{fullCommentName}}"/> from a string
    /// </summary>
    /// <param name="str"></param>
    public static implicit operator {{fullName}}(string str)
    {
        if (typeof({{arrayType}}) == typeof(char) || typeof({{arrayType}}) == typeof(ushort) || typeof({{arrayType}}) == typeof(short))
        {
            return new {{fullName}}(
                ref Unsafe.As<char, T>(ref Unsafe.AsRef(in str.GetPinnableReference()))
            );
        }

        if (typeof({{arrayType}}) == typeof(byte) || typeof({{arrayType}}) == typeof(sbyte))
        {
            return new {{fullName}}(
                ref Unsafe.As<byte, T>(ref Unsafe.AsRef(in SilkMarshal.StringToNative(str)))
            );
        }

        if (typeof({{arrayType}}) == typeof(uint) || typeof({{arrayType}}) == typeof(int))
        {
            return new {{fullName}}(
                ref Unsafe.As<byte, T>(ref Unsafe.AsRef(in SilkMarshal.StringToNative(str, 4)))
            );
        }

        static void Throw() => throw new InvalidCastException();
        Throw();
        return default;
    }
}
""" :
$$"""


    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a ReadOnlySpan
    /// </summary>
    /// <param name="span"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(ReadOnlySpan<{{arrayType}}> span) => new(in span.GetPinnableReference());
}
"""));
        }

        private static string GeneratePointerType(out string name, bool generic, params PointerType[] types)
        {
            name = string.Empty;
            if (types.Length == 0)
                return string.Empty;
            if (types.Length == 1)
                return GenerateSingleDimensionPointerType(out name, generic, types[0]);

            bool outerMutability = OUTERMOST_ON_RIGHT ? types.Last() == PointerType.Mut : types[0] == PointerType.Mut;
            bool innerMutability = OUTERMOST_ON_RIGHT ? types[0] == PointerType.Mut : types.Last() == PointerType.Mut;
            name = string.Join("", types);
            string upperType = OUTERMOST_ON_RIGHT ? name.Remove(name.Length - 3) : name.Remove(0, 3);
            string fullName = name;
            string fullCommentName = name;
            string rOField = outerMutability ? string.Empty : "readonly ";
            string rOInRef = outerMutability ? "ref" : "in";
            string spanType = outerMutability ? "Span" : "ReadOnlySpan";

            string arrayType;
            string arrayConversions = string.Empty;
            string typeRef;
            string upperTypeRef = string.Empty;
            string indexer;
            string whereClause = string.Empty;
            if (generic)
            {
                arrayType = "T";
                fullName += "<T>";
                fullCommentName += "{T}";
                whereClause = "\n\twhere T : unmanaged";

                typeRef = $"(typeof({name}<>).MakeGenericType(typeof(T)))";
                if (types.Length > 1)
                {
                    upperTypeRef = $"(typeof({upperType}<>).MakeGenericType(typeof(T)))";
                    upperType += "<T>";

                    string ILType = types.Length > 1 ? "nuint" : arrayType;

                    indexer =
$"""
IL.Emit.Ldarg_0();
            IL.Emit.Ldfld(
                FieldRef.Field(
                    TypeRef.Type{typeRef},
                    nameof(InteriorRef)
                )
            );
            IL.Emit.Ldarg_1();
            IL.Emit.Sizeof<{ILType}>();
            IL.Emit.Mul();
            IL.Emit.Add();
            IL.Emit.Ret();
            throw IL.Unreachable();
""";
                }
                else
                {
                    upperType = "T";
                    indexer = "return ref Unsafe.Add(ref Unsafe.AsRef(in Ref), index);";
                }
            }
            else
            {
                arrayType = "byte";
                typeRef = $"(typeof({name}))";
                upperTypeRef = $"(typeof({upperType}))";

                string ILType = types.Length > 1 ? "nuint" : arrayType;

                indexer =
$"""
IL.Emit.Ldarg_0();
            IL.Emit.Ldfld(
                FieldRef.Field(
                    TypeRef.Type{typeRef},
                    nameof(InteriorRef)
                )
            );
            IL.Emit.Ldarg_1();
            IL.Emit.Sizeof<{ILType}>();
            IL.Emit.Mul();
            IL.Emit.Add();
            IL.Emit.Ret();
            throw IL.Unreachable();
""";
            }

            string ptrChars = "*";
            string pinRefptr = string.Empty;
            ptrChars = string.Empty;
            string arrayChars = string.Empty;
            string lengthParams = string.Empty;
            string lengthComments = string.Empty;
            string stringArraySpecChars = string.Empty;

            for (int i = 0; i < types.Length; i++)
            {
                ptrChars += "*";
                arrayChars += "[]";

                if (i < types.Length - 1)
                {
                    stringArraySpecChars += "[]?";
                    lengthParams += $"int length{i}, ";
                    lengthComments += $"\t/// <param name=\"length{i}\">The number of strings contained in the {i}-level of the string array.</param>\n";
                }
            }
            string stringArrayChars = arrayChars.Remove(arrayChars.Length - 4);
            lengthParams = lengthParams.Remove(lengthParams.Length - 2);
            pinRefptr = ptrChars.Remove(ptrChars.Length - 1);
            arrayConversions =
$$"""

    /// <summary>
    /// creates a <see cref="{{fullCommentName}}"/> from an array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}({{arrayType}}{{arrayChars}} array)
        => SilkMarshal.JaggedArrayToPointerArray<{{arrayType}}>(array);

    /// <summary>
    /// creates a <see cref="{{fullCommentName}}"/> from a pointer array
    /// </summary>
    /// <param name="array"></param>
    public static implicit operator {{fullName}}({{arrayType}}{{pinRefptr}}[] array)
    {
        IL.Emit.Ldarg_0();
        IL.Emit.Ldc_I4_0();
        IL.Emit.Ldelema(TypeRef.Type(typeof({{arrayType}}).MakePointerType()));
        IL.Emit.Newobj(
            MethodRef.Constructor(
                TypeRef.Type{{typeRef}},
                TypeRef.Type{{upperTypeRef}}.MakeByRefType()
            )
        );
        IL.Emit.Ret();
        throw IL.Unreachable();
    }
""" + (outerMutability ? "" : (generic ?
$$"""


    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a string span.
    /// </summary>
    /// <param name="span">The array.</param>
    /// <returns>The pointer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(Span<string{{stringArrayChars}}> span)
    {
        if (
            typeof({{arrayType}}) != typeof(byte)
            && typeof({{arrayType}}) != typeof(sbyte)
            && typeof({{arrayType}}) != typeof(char)
            && typeof({{arrayType}}) != typeof(short)
            && typeof({{arrayType}}) != typeof(ushort)
            && typeof({{arrayType}}) != typeof(int)
            && typeof({{arrayType}}) != typeof(uint)
        )
        {
            throw new InvalidCastException();
        }

        return new {{fullName}}(ref SilkMarshal.StringArrayToNative(span, sizeof({{arrayType}})));
    }

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a string span.
    /// </summary>
    /// <param name="span">The array.</param>
    /// <returns>The pointer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(ReadOnlySpan<string{{stringArrayChars}}> span)
    {
        if (
            typeof({{arrayType}}) != typeof(byte)
            && typeof({{arrayType}}) != typeof(sbyte)
            && typeof({{arrayType}}) != typeof(char)
            && typeof({{arrayType}}) != typeof(short)
            && typeof({{arrayType}}) != typeof(ushort)
            && typeof({{arrayType}}) != typeof(int)
            && typeof({{arrayType}}) != typeof(uint)
        )
        {
            throw new InvalidCastException();
        }

        return new {{fullName}}(ref SilkMarshal.StringArrayToNative(span, sizeof({{arrayType}})));
    }

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a string array.
    /// </summary>
    /// <param name="array">The array.</param>
    /// <returns>The pointer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(string[]{{stringArrayChars}} array)
    {
        if (
            typeof({{arrayType}}) != typeof(byte)
            && typeof({{arrayType}}) != typeof(sbyte)
            && typeof({{arrayType}}) != typeof(char)
            && typeof({{arrayType}}) != typeof(short)
            && typeof({{arrayType}}) != typeof(ushort)
            && typeof({{arrayType}}) != typeof(int)
            && typeof({{arrayType}}) != typeof(uint)
        )
        {
            throw new InvalidCastException();
        }

        return new {{fullName}}(ref SilkMarshal.StringArrayToNative(array, sizeof({{arrayType}})));
    }
""" :
$$"""
    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a string span.
    /// </summary>
    /// <param name="span">The array.</param>
    /// <returns>The pointer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(Span<string{{stringArrayChars}}> span)
    {
        return new {{fullName}}(ref SilkMarshal.StringArrayToNative(span, sizeof(byte)));
    }


    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a string span.
    /// </summary>
    /// <param name="span">The array.</param>
    /// <returns>The pointer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(ReadOnlySpan<string{{stringArrayChars}}> span)
    {
        return new {{fullName}}(ref SilkMarshal.StringArrayToNative(span, sizeof(byte)));
    }

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a string array.
    /// </summary>
    /// <param name="array">The array.</param>
    /// <returns>The pointer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(string[]{{stringArrayChars}} array)
    {
        return new {{fullName}}(ref SilkMarshal.StringArrayToNative(array, sizeof(byte)));
    }
"""));

            return
$$"""
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// ============================================= THIS FILE IS AUTOGENERATED ============================================
// =============================== Please make any edits in eng/pointergen/Generator.cs! ===============================
// ============================================= THIS FILE IS AUTOGENERATED ============================================

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using InlineIL;

namespace Silk.NET.Core;

/// <summary>
/// A pointer wrapper class
/// </summary>
public unsafe readonly ref struct {{fullName}} {{whereClause}}
{
    /// <summary>
    /// Creates a pointer with the given underlying ref.
    /// </summary>
    /// <param name="Ref">The underlying ref.</param>
    public {{name}}(ref {{rOField}}{{upperType}} @Ref)
    {
        IL.Emit.Ldarg_0();
        IL.Emit.Ldarg_1();
        IL.Emit.Stfld(
            FieldRef.Field(
                TypeRef.Type{{typeRef}},
                nameof(InteriorRef)
            )
        );
        IL.Emit.Ret();
        throw IL.Unreachable();
    }

    /// <summary>
    /// Creates a pointer with the given underlying ref.
    /// </summary>
    /// <param name="InteriorRef">The underlying ref.</param>
    internal {{name}}(ref {{rOField}}byte @InteriorRef)
    {
        this.InteriorRef = ref @InteriorRef; 
    }

    /// <summary>
    /// The underlying reference
    /// </summary>
    public readonly ref {{rOField}}{{upperType}} Ref
    {
        [MethodImpl(
            MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization
        )]
        get
        {
            // Would use the delegate* trick but this isn't optimised in JIT yet or necessarily safe
            IL.Emit.Ldarg_0();
            IL.Emit.Ldfld(
            FieldRef.Field(
                    TypeRef.Type{{typeRef}},
                                    nameof(InteriorRef)
                                )
                            );
            IL.Emit.Ret();
            throw IL.Unreachable();
        }
    }

    /// <summary>
    /// The underlying generic reference
    /// </summary>
    public readonly ref readonly byte GetInteriorRef() => ref InteriorRef;

    private readonly ref {{rOField}}byte InteriorRef;

    /// <summary>
    /// Gets the item at the given offset from this pointer.
    /// </summary>
    /// <param name="index">The index.</param>
    public ref {{rOField}}{{upperType}} this[nuint index]
    {
        [MethodImpl(
        MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization
    )]
        get
        {
            {{indexer}}
        }
    }

    /// <summary>
    /// Gets the underlying reference.
    /// </summary>
    /// <returns>The underlying reference.</returns>
    /// <remarks>
    /// This function allows a <see cref="{{fullCommentName}}"/> to be used in a <c>fixed</c> statement.
    /// </remarks>
    public ref {{rOField}}{{arrayType}}{{pinRefptr}} GetPinnableReference()
    {
        IL.Emit.Ldarg_0();
        IL.Emit.Ldfld(
            FieldRef.Field(
                TypeRef.Type{{typeRef}},
                nameof(InteriorRef)
            )
        );
        IL.Emit.Ret();
        throw IL.Unreachable();
    }

    /// <summary>
    /// Determines if this <see cref="{{fullCommentName}}"/> equals another object
    /// Always returns false as ref structs cannot be passed in, so it will never be true
    /// </summary>
    /// <param name="obj"></param>
    /// <returns>Whether this object is the same as </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public override bool Equals([NotNullWhen(true)] object? obj) => false;

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public override int GetHashCode() => InteriorRef.GetHashCode();

    /// <summary>
    /// Determines if two <see cref="{{fullCommentName}}"/> objects are equivalent
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the pointers are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==({{fullName}} lh, {{fullName}} rh) => (void*)lh == (void*)rh;

    /// <summary>
    /// Determines if two <see cref="{{fullCommentName}}"/> objects are not equivalent
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the pointers are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=({{fullName}} lh, {{fullName}} rh) => (void*)lh != (void*)rh;

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a Nullptr
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator {{fullName}}(NullPtr ptr) => (void*)ptr;

    /// <summary>
    /// Determines whether a <see cref="{{fullCommentName}}"/> and a NullPtr are equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the <see cref="{{fullCommentName}}"/> and NullPtr are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==({{fullName}} lh, NullPtr rh) => lh == ({{fullName}})rh;

    /// <summary>
    /// Determines whether a <see cref="{{fullCommentName}}"/> and a NullPtr are not equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the <see cref="{{fullCommentName}}"/> and NullPtr are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=({{fullName}} lh, NullPtr rh) => lh != ({{fullName}})rh;

    /// <summary>
    /// Determines whether a NullPtr and a <see cref="{{fullCommentName}}"/> are equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the NullPtr and <see cref="{{fullCommentName}}"/> are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==(NullPtr lh, {{fullName}} rh) => ({{fullName}})lh == rh;

    /// <summary>
    /// Determines whether a NullPtr and a <see cref="{{fullCommentName}}"/> are not equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the NullPtr and <see cref="{{fullCommentName}}"/> are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=(NullPtr lh, {{fullName}} rh) => ({{fullName}})lh != rh;

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a void pointer
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}(void* ptr) => new(ref Unsafe.AsRef<byte>(ptr));

    /// <summary>
    /// Creates a void pointer from a <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static explicit operator void*({{fullName}} ptr) => Unsafe.AsPointer(ref Unsafe.AsRef(in ptr.InteriorRef));

    /// <summary>
    /// Creates a <see cref="{{fullCommentName}}"/> from a pointer
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator {{fullName}}({{arrayType}}{{ptrChars}} ptr) => new(ref Unsafe.AsRef<byte>(ptr));

    /// <summary>
    /// Creates a pointer from a <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static explicit operator {{arrayType}}{{ptrChars}}({{fullName}} ptr) => ({{arrayType}}{{ptrChars}})Unsafe.AsPointer(ref Unsafe.AsRef(in ptr.InteriorRef));
    {{arrayConversions}}
""" + (generic ?
$$"""


    /// <summary>
    /// Create a non-generic version of <see cref="{{fullCommentName}}"/>
    /// </summary>
    /// <param name="ptr"></param>
    public static implicit operator {{name}}({{fullName}} ptr) => new {{name}}({{rOInRef}} ptr.InteriorRef);
}
""" : "\n}");
        }
    }
}
